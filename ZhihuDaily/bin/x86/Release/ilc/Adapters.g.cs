#define MCG_WINRT_SUPPORTED
using Mcg.System;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.WindowsRuntime;


// -----------------------------------------------------------------------------------------------------------
// 
// WARNING: THIS SOURCE FILE IS FOR 32-BIT BUILDS ONLY!
// 
// MCG GENERATED CODE
// 
// This C# source file is generated by MCG and is added into the application at compile time to support interop features.
// 
// It has three primary components:
// 
// 1. Public type definitions with interop implementation used by this application including WinRT & COM data structures and P/Invokes.
// 
// 2. The 'McgInterop' class containing marshaling code that acts as a bridge from managed code to native code.
// 
// 3. The 'McgNative' class containing marshaling code and native type definitions that call into native code and are called by native code.
// 
// -----------------------------------------------------------------------------------------------------------
// 
// warning CS0067: The event 'event' is never used
#pragma warning disable 67
// warning CS0169: The field 'field' is never used
#pragma warning disable 169
// warning CS0649: Field 'field' is never assigned to, and will always have its default value 0
#pragma warning disable 649
// warning CS1591: Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// warning CS0108 'member1' hides inherited member 'member2'. Use the new keyword if hiding was intended.
#pragma warning disable 108
// warning CS0114 'member1' hides inherited member 'member2'.  To make the current method override that implementation, add the override keyword. Otherwise add the new keyword.
#pragma warning disable 114
// warning CS0659 'type' overrides Object.Equals but does not override GetHashCode.
#pragma warning disable 659
// warning CS0465 Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?
#pragma warning disable 465
// warning CS0028 'function declaration' has the wrong signature to be an entry point
#pragma warning disable 28
// warning CS0162 Unreachable code Detected
#pragma warning disable 162
// warning CS0628 new protected member declared in sealed class
#pragma warning disable 628

namespace System.Runtime.InteropServices.WindowsRuntime
{
	public static class ListToBindableVectorAdapter 
	{
	    public static object GetAt(global::System.Collections.IList _this, uint index)
	    {
	        EnsureIndexInt32(index);
	        try
	        {
	            return _this[(System.Int32)index];
	        }
	        catch (System.ArgumentOutOfRangeException ex)
	        {
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_BOUNDS);
	            throw;
	        }
	    }

	    public static uint get_Size(global::System.Collections.IList _this)
	    {
	        return (uint)_this.Count;
	    }

	    public static global::Windows.UI.Xaml.Interop.IBindableVectorView GetView(global::System.Collections.IList _this)
	    {
	        return new ListToBindableVectorViewAdapter(_this);

	    }
	    
	    public static bool IndexOf(
	                global::System.Collections.IList _this,
	                object value,
	                out uint index)
	    {
	        int ind = _this.IndexOf(value);
	        if (-1 == ind)
	        {
	            index = 0;
	            return false;
	        }
	        index = (uint)ind;
	        return true;

	    }
	    public static void SetAt(
	                global::System.Collections.IList _this,
	                uint index,
	                object value)
	    {
	        EnsureIndexInt32(index);
	        try
	        {
	            _this[(int)index] = value;
	        }
	        catch (System.ArgumentOutOfRangeException  ex)
	        {
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_BOUNDS);
	            throw;
	        }

	    }
	    public static void InsertAt(
	                global::System.Collections.IList _this,
	                uint index,
	                object value)
	    {
	        EnsureIndexInt32(index);
	        try
	        {
	            _this.Insert((int)index, value);
	        }
	        catch (System.ArgumentOutOfRangeException ex)
	        {
	            // Change error code to match what WinRT expects
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_BOUNDS);
	            throw;
	        }

	    }
	    public static void RemoveAt(
	                global::System.Collections.IList _this,
	                uint index)
	    {
	        EnsureIndexInt32(index);
	        try
	        {
	            _this.RemoveAt((int)index);
	        }
	        catch (System.ArgumentOutOfRangeException ex)
	        {
	            // Change error code to match what WinRT expects
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_BOUNDS);
	            throw;
	        }

	    }
	    public static void Append(global::System.Collections.IList _this, object value)
	    {
	        _this.Add(value);
	    }
	    
	    public static void RemoveAtEnd(global::System.Collections.IList _this)
	    {
	        if (_this.Count == 0)
	        {
	            InvalidOperationException ex = new InvalidOperationException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_CannotRemoveFromEmptyCollection));

	            // Change error code to match what WinRT expects
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_BOUNDS);
	            throw ex;
	        }
	        uint size = (uint)_this.Count;
	        RemoveAt(_this, size - 1);
	    }

	    public static void Clear(global::System.Collections.IList _this)
	    {
	        _this.Clear();

	    }

	    static void EnsureIndexInt32(uint index)
	    {
	        // We use '<=' and not '<' becasue Int32.MaxValue == index would imply
	        // that Size > Int32.MaxValue:
	        if (((uint)System.Int32.MaxValue) <= index)
	        {
	            throw global::McgInterop.Helpers.NewException_ArgumentOutOfRangeException_index_BOUNDS();
	        }
	    }
	}

	public class ListToBindableVectorViewAdapter : global::Windows.UI.Xaml.Interop.IBindableVectorView
	{
	    global::System.Collections.IList list;
	    
	    public ListToBindableVectorViewAdapter(System.Collections.IList list)
	    {
	        this.list = list;
	    }
	    
	    void EnsureIndexInt32(uint index)
	    {
	        // We use '<=' and not '<' becasue Int32.MaxValue == index would imply
	        // that Size > Int32.MaxValue:
	        if (((uint)System.Int32.MaxValue) <= index)
	        {
	            throw global::McgInterop.Helpers.NewException_ArgumentOutOfRangeException_index_BOUNDS();
	        }
	    }
	    
	    public virtual global::System.Collections.IEnumerator GetEnumerator()
	    {
	        return list.GetEnumerator();
	    }
	    
	    public virtual object GetAt(uint index)
	    {
	        EnsureIndexInt32(index);

	        try
	        {
	            return list[(int)index];
	        }
	        catch (System.ArgumentOutOfRangeException ex)
	        {
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_BOUNDS);
	            throw;
	        }
	    }
	    
	    [global::System.Runtime.InteropServices.McgAccessor(global::System.Runtime.InteropServices.McgAccessorKind.PropertyGet, "Size")]
	    public virtual uint get_Size()
	    {
	        return (uint)list.Count;
	    }
	    
	    public virtual bool IndexOf(object value, out uint index)
	    {
	        int ind = list.IndexOf(value);

	        if (-1 == ind)
	        {
	            index = 0;
	            return false;
	        }
	        
	        index = (uint)ind;
	        return true;
	    }
	}

	public static class EnumerableToBindableIterableAdapter 
	{
	    public static global::Windows.UI.Xaml.Interop.IBindableIterator First(global::System.Collections.IEnumerable _this)
	    {
	        return new EnumeratorToBindableIteratorAdapter(_this.GetEnumerator());
	    }
	}

	public class BindableIteratorToEnumeratorAdapter : global::System.Collections.IEnumerator
	{
	    global::Windows.UI.Xaml.Interop.IBindableIterator m_iterator;
	    object m_current;
	    bool m_hadCurrent;
	    bool m_isInitialized;

	    public BindableIteratorToEnumeratorAdapter(global::Windows.UI.Xaml.Interop.IBindableIterator iterator)
	    {
	        m_iterator = iterator;
	        m_hadCurrent = true;
	        m_isInitialized = false;
	    }

	    public virtual object Current
	    {
	        get
	        {
	            // The enumerator has not been advanced to the first element yet.
	            if (!m_isInitialized)
	            {
	                throw new InvalidOperationException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_EnumNotStarted));
	            }
	            
	            // The enumerator has reached the end of the collection
	            if (!m_hadCurrent)
	            {
	                throw new InvalidOperationException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_EnumEnded));
	            }
	            
	            return m_current;
	        }
	    }

	    public virtual bool MoveNext()
	    {
	        if (!m_hadCurrent)
	        {
	            return false;
	        }

	        // IIterators start at index 0, rather than -1.  If this is the first call, we need to just
	        // check HasCurrent rather than actually moving to the next element
	        try
	        {
	            if (!m_isInitialized)
	            {
	                m_hadCurrent = m_iterator.get_HasCurrent();
	                m_isInitialized = true;
	            }
	            else
	            {
	                m_hadCurrent = m_iterator.MoveNext();
	            }

	            // We want to save away the current value for two reasons:
	            //  1. Accessing .Current is cheap on other iterators, so having it be a property which is a
	            //     simple field access preserves the expected performance characteristics (as opposed to
	            //     triggering a COM call every time the property is accessed)
	            //
	            //  2. This allows us to preserve the same semantics as generic collection iteration when iterating
	            //     beyond the end of the collection - namely that Current continues to return the last value
	            //     of the collection
	            if (m_hadCurrent)
	            {
	                m_current = m_iterator.get_Current();
	            }
	        }
	        catch (global::System.Exception ex)
	        {
	            // Translate E_CHANGED_STATE into an InvalidOperationException for an updated enumeration
	            if (global::McgInterop.McgHelpers.__HResults.E_CHANGED_STATE == ex.HResult)
	            {
	                throw new InvalidOperationException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_EnumFailedVersion));
	            }

	            throw;
	        }

	        return m_hadCurrent;
	    }

	    public virtual void Reset()
	    {
	        throw new NotSupportedException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_NotSupported));
	    }

	    public virtual void Dispose()
	    {
	    }
	}

	public class EnumeratorToBindableIteratorAdapter : global::Windows.UI.Xaml.Interop.IBindableIterator
	    // Jupiter will reinterpret cast IBindableIterable to IIterable<object> and call .First
	    // which means we may get returned an EnumeratorToBindableIteratorAdapter when we expect
	    // an IIterator<object>, so we need to implement that as well
	    , global::Windows.Foundation.Collections.IIterator<object>
	{
	    global::System.Collections.IEnumerator m_enumerator;
	    bool m_hasCurrent;
	    bool m_firstItem = true;

	    public EnumeratorToBindableIteratorAdapter(System.Collections.IEnumerator enumerator)
	    {
	        m_enumerator = enumerator;
	    }

	    [global::System.Runtime.InteropServices.McgAccessor(global::System.Runtime.InteropServices.McgAccessorKind.PropertyGet, "Current")]
	    public virtual object get_Current()
	    {
	        if (m_firstItem)
	        {
	            m_firstItem = false;
	            MoveNext();
	        }

	        if (! m_hasCurrent)
	        {
	            throw global::McgInterop.Helpers.NewException_ArgumentOutOfRangeException_index_BOUNDS();
	        }

	        return m_enumerator.Current;
	    }

	    [global::System.Runtime.InteropServices.McgAccessor(global::System.Runtime.InteropServices.McgAccessorKind.PropertyGet, "HasCurrent")]
	    public virtual bool get_HasCurrent()
	    {
	        if (m_firstItem)
	        {
	            m_firstItem = false;
	            MoveNext();
	        }

	        return m_hasCurrent;
	    }

	    public virtual bool MoveNext()
	    {
	        try
	        {
	            m_hasCurrent = m_enumerator.MoveNext();
	        }
	        catch (System.InvalidOperationException ex)
	        {
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_CHANGED_STATE);
	            throw;
	        }

	        return m_hasCurrent;
	    }

	    uint global::Windows.Foundation.Collections.IIterator<object>.GetMany(object[] items)
	    {
	        if (items == null)
	        {
	            return 0;
	        }

	        int index = 0;
	        
	        while (index < items.Length && get_HasCurrent())
	        {
	            items[index] = get_Current();
	            MoveNext();
	            ++index;
	        }

	        return (uint)index;
	    }
	}

	public sealed class EnumeratorToIteratorAdapter<T> : global::Windows.Foundation.Collections.IIterator<T>
	{
	    private global::System.Collections.Generic.IEnumerator<T> m_enumerator;
	    private bool m_firstItem = true;
	    private bool m_hasCurrent;

	    public EnumeratorToIteratorAdapter(System.Collections.Generic.IEnumerator<T> enumerator)
	    {
	        //Contract.Requires(enumerator != null);
	        m_enumerator = enumerator;
	    }

	    [global::System.Runtime.InteropServices.McgAccessor(global::System.Runtime.InteropServices.McgAccessorKind.PropertyGet, "Current")]
	    public T get_Current()
	    {
	        // IEnumerator starts at item -1, while IIterators start at item 0.  Therefore, if this is the
	        // first access to the iterator we need to advance to the first item.
	        if (m_firstItem)
	        {
	            m_firstItem = false;
	            MoveNext();
	        }

	        if (!m_hasCurrent)
	        {
	            throw global::McgInterop.Helpers.NewException_ArgumentOutOfRangeException_index_BOUNDS();
	        }

	        return m_enumerator.Current;
	    }

	    [global::System.Runtime.InteropServices.McgAccessor(global::System.Runtime.InteropServices.McgAccessorKind.PropertyGet, "HasCurrent")]
	    public bool get_HasCurrent()
	    {
	        // IEnumerator starts at item -1, while IIterators start at item 0.  Therefore, if this is the
	        // first access to the iterator we need to advance to the first item.
	        if (m_firstItem)
	        {
	            m_firstItem = false;
	            MoveNext();
	        }

	        return m_hasCurrent;
	    }

	    public bool MoveNext()
	    {
	        try
	        {
	            m_hasCurrent = m_enumerator.MoveNext();
	        }
	        catch (System.InvalidOperationException ex)
	        {
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_CHANGED_STATE);
	            throw;
	        }

	        return m_hasCurrent;
	    }

	    public uint GetMany(T[] items)
	    {
	        if (items == null)
	        {
	            return 0;
	        }

	        int index = 0;

	        while (index < items.Length && get_HasCurrent())
	        {
	            items[index] = get_Current();
	            MoveNext();
	            ++index;
	        }

	        if (typeof(T) == typeof(string))
	        {
	            string[] stringItems = items as string[];

	            // Fill the rest of the array with String.Empty to avoid marshaling failure
	            for (int i = index; i < items.Length; ++i)
	                stringItems[i] = global::System.String.Empty;
	        }

	        return (uint)index;
	    }
	}


	public static class EnumerableToIterableAdapter 
	{
	    public static global::Windows.Foundation.Collections.IIterator<T> First<T>(global::System.Collections.Generic.IEnumerable<T> _this)
	    {
	        return new EnumeratorToIteratorAdapter<T>(_this.GetEnumerator());
	    }
	}

	public sealed class IteratorToEnumeratorAdapter<T> : global::System.Collections.Generic.IEnumerator<T>
	{
	    private global::Windows.Foundation.Collections.IIterator<T> m_iterator;
	    private bool m_hadCurrent;
	    private T m_current;
	    private bool m_isInitialized;

	    internal IteratorToEnumeratorAdapter(global::Windows.Foundation.Collections.IIterator<T> iterator)
	    {
	        //Contract.Requires(iterator != null);
	        m_iterator = iterator;
	        m_hadCurrent = true;
	        m_isInitialized = false;
	    }

	    public T Current
	    {
	        get
	        {
	            // The enumerator has not been advanced to the first element yet.
	            if (!m_isInitialized)
	            {
	                throw new InvalidOperationException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_EnumNotStarted));
	            }

	            // The enumerator has reached the end of the collection
	            if (!m_hadCurrent)
	            {
	                throw new InvalidOperationException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_EnumEnded));
	            }
	            
	            return m_current;
	        }
	    }

	    object global::System.Collections.IEnumerator.Current
	    {
	        get
	        {
	            // The enumerator has not been advanced to the first element yet.
	            if (!m_isInitialized)
	            {
	                throw new InvalidOperationException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_EnumNotStarted));
	            }
	            
	            // The enumerator has reached the end of the collection
	            if (!m_hadCurrent)
	            {
	                throw new InvalidOperationException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_EnumEnded));
	            }
	            
	            return m_current;
	        }
	    }
	    
	    public bool MoveNext()
	    {
	        // If we've passed the end of the iteration, IEnumerable<T> should return false, while
	        // IIterable will fail the interface call
	        if (!m_hadCurrent)
	        {
	            return false;
	        }

	        // IIterators start at index 0, rather than -1.  If this is the first call, we need to just
	        // check HasCurrent rather than actually moving to the next element
	        try
	        {
	            if (!m_isInitialized)
	            {
	                m_hadCurrent = m_iterator.get_HasCurrent();
	                m_isInitialized = true;
	            }
	            else
	            {
	                m_hadCurrent = m_iterator.MoveNext();
	            }

	            // We want to save away the current value for two reasons:
	            //  1. Accessing .Current is cheap on other iterators, so having it be a property which is a
	            //     simple field access preserves the expected performance characteristics (as opposed to
	            //     triggering a COM call every time the property is accessed)
	            //
	            //  2. This allows us to preserve the same semantics as generic collection iteration when iterating
	            //     beyond the end of the collection - namely that Current continues to return the last value
	            //     of the collection
	            if (m_hadCurrent)
	            {
	                m_current = m_iterator.get_Current();
	            }
	        }
	        catch (System.Exception ex)
	        {
	            // Translate E_CHANGED_STATE into an InvalidOperationException for an updated enumeration
	            if (global::McgInterop.McgHelpers.__HResults.E_CHANGED_STATE == ex.HResult)
	            {
	                throw new InvalidOperationException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_EnumFailedVersion));
	            }

	            throw;
	        }

	        return m_hadCurrent;
	    }

	    public void Reset()
	    {
	        throw new NotSupportedException();
	    }

	    public void Dispose()
	    {
	    }
	}


	// IReadOnlyCollection is generic, so we can't invoke Count without knowing T.  Instead, we 
	// introduce a new non-generic interface for our adapters, so we can have a non-generic helper 
	// for the call.
	public interface IReadOnlyCollectionAdapter
	{
	    int Count { get; }
	}

	public interface IReadOnlyListAdapter<out T> : IReadOnlyCollectionAdapter
	{
	    T this[int index] { get; }
	}


	// Specialization: GetMany,string
	public static class ReadOnlyListToVectorViewAdapter 
	{
	    // T GetAt(uint index)
	    public static T GetAt<T>(
	        global::System.Collections.Generic.IReadOnlyList<T> _this,
	        uint index)
	    {
	        EnsureIndexInt32(index);

	        try
	        {
	            return _this[(int)index];
	        }
	        catch (System.ArgumentOutOfRangeException ex)
	        {
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_BOUNDS);
	            throw;
	        }
	    }

	    // uint Size { get }
	    public static uint get_Size<T>(global::System.Collections.Generic.IReadOnlyCollection<T> _this)
	    { 
	        return (uint)_this.Count;
	    }

	    // bool IndexOf(T value, out uint index)
	    public static bool IndexOf<T>(
	        global::System.Collections.Generic.IReadOnlyList<T> _this, 
	        T value, 
	        out uint index)
	    {
	        int max = _this.Count;

	        for (int i = 0; i < max; i++)
	        {
	            if (global::System.Runtime.InteropServices.McgMarshal.ComparerEquals<T>(value, _this[i]))
	            {
	                index = (uint) i;
	                return true;
	            }
	        }

	        index = 0;
	        return false;
	    }

	    // uint GetMany(uint startIndex, T[] items)
	    public static uint GetMany<T>(global::System.Collections.Generic.IReadOnlyList<T> _this, 
	        uint startIndex, 
	        T[] items)
	    {
	        return GetManyHelper<T>(_this, startIndex, items);
	    }

	    // @TODO - Weird shared CCW support that I don't really understand. Get rid of this.
	    public static uint GetMany_string(global::System.Collections.Generic.IReadOnlyList<string> _this,
	        uint startIndex,
	        string[] items)
	    {
	        return GetManyHelper<string>(_this, startIndex, items);
	    }

	    private static uint GetManyHelper<T>(global::System.Collections.Generic.IReadOnlyList<T> _this,
	        uint startIndex,
	        T[] items)
	    {
	        int count = _this.Count;

	        // REX spec says "calling GetMany with startIndex equal to the length of the vector 
	        // (last valid index + 1) and any specified capacity will succeed and return zero actual
	        // elements".
	        if (startIndex == count)
	            return 0;

	        if (startIndex > (uint)count)
	        {
	            throw global::McgInterop.Helpers.NewException_ArgumentOutOfRangeException_index_BOUNDS();
	        }

	        EnsureIndexInt32(startIndex);

	        if (items == null)
	        {
	            return 0;
	        }

	        uint itemCount = global::System.Math.Min((uint)items.Length, (uint)count - startIndex);

	        for (uint i = 0; i < itemCount; ++i)
	        {
	            items[i] = _this[(int)(i + startIndex)];
	        }

	        return itemCount;
	    }

	    #region Helpers

	    private static void EnsureIndexInt32(uint index)
	    {
	        // We use '<=' and not '<' because Int32.MaxValue == index would imply
	        // that Size > Int32.MaxValue:
	        if (((uint)System.Int32.MaxValue) <= index)
	        {
	            throw global::McgInterop.Helpers.NewException_ArgumentOutOfRangeException_index_BOUNDS();
	        }
	    }

	    #endregion Helpers
	}

	public static class DisposableToClosableAdapter
	{
	    internal static void Close(System.IDisposable disposable)
	    {
	        disposable.Dispose();
	    }
	}

	public static class ICommandToWinRTAdapter 
	{
	    /// <summary>
	    /// The mapping from each ICommand instance to its corresponding EventRegistrationTokenTable instance
	    /// The EventRegistrationTokenTable maintains delegate->Token mapping for subscription and unsubscription
	    /// </summary>
	    private static global::System.Runtime.CompilerServices.ConditionalWeakTable<System.Windows.Input.ICommand, global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.EventHandler>> m_weakTable =
	        new global::System.Runtime.CompilerServices.ConditionalWeakTable<System.Windows.Input.ICommand, global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.EventHandler>>();

	    // global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken add_CanExecuteChanged(System.EventHandler<object> value)
	    public static global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken add_CanExecuteChanged(
	        global::System.Windows.Input.ICommand _this, 
	        global::System.EventHandler<object> value
	        )
	    {
	        //
	        // Retrieve the corresponding EventRegistrationTokenTable for this particular instance
	        //
	        global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.EventHandler> table =
	            m_weakTable.GetValue(_this, CreateTableForICommand);

	        //
	        // Build a "delegate adapter" that simply pass through the arguments
	        //
	        global::System.EventHandler handler = (object sender, global::System.EventArgs e) => value(sender, e);

	        //
	        // Add the delegate into the EventRegistrationTokenTable and gets back the token
	        // Then subscribe to the event
	        //
	        global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token = table.AddEventHandler(handler);
	        _this.CanExecuteChanged += handler;

	        return token;
	    }

	    // void PropertyChanged.remove(System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token)
	    public static void remove_CanExecuteChanged(
	        global::System.Windows.Input.ICommand _this,
	        global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token)
	    {
	        //
	        // Retrieve the corresponding EventRegistrationTokenTable for this particular instance
	        //
	        global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.EventHandler> table =
	            m_weakTable.GetValue(_this, CreateTableForICommand);

	        //
	        // Return the corresponding event handler from the given token and unsubscribe
	        //
	        global::System.EventHandler handler = 
	            global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationHelpers.ExtractHandler(table, token);
	        if (handler != null)
	        {
	            _this.CanExecuteChanged -= handler;
	        }
	    }

	    public static bool CanExecute(System.Windows.Input.ICommand _this, object parameter)
	    {
	        return _this.CanExecute(parameter);
	    }

	    public static void Execute(System.Windows.Input.ICommand _this, object parameter)
	    {
	        _this.Execute(parameter);
	    }

	    private static global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.EventHandler> 
	        CreateTableForICommand(System.Windows.Input.ICommand command)
	    {
	        return new global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.EventHandler>();
	    }
	}

	public static class NotifyCollectionChangedToWinRTAdapter 
	{
	    private static global::System.Runtime.CompilerServices.ConditionalWeakTable<System.Collections.Specialized.INotifyCollectionChanged, global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.Collections.Specialized.NotifyCollectionChangedEventHandler>> m_weakTable;

	    private static global::System.Runtime.CompilerServices.ConditionalWeakTable<System.Collections.Specialized.INotifyCollectionChanged, global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.Collections.Specialized.NotifyCollectionChangedEventHandler>> WeakTable
	    {
	        get
	        {
	            if (m_weakTable == null)
	            {
	                global::System.Runtime.CompilerServices.ConditionalWeakTable<System.Collections.Specialized.INotifyCollectionChanged, global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.Collections.Specialized.NotifyCollectionChangedEventHandler>> weakTable = new global::System.Runtime.CompilerServices.ConditionalWeakTable<System.Collections.Specialized.INotifyCollectionChanged, global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.Collections.Specialized.NotifyCollectionChangedEventHandler>>();
	                global::System.Threading.Interlocked.CompareExchange(ref m_weakTable, weakTable, null);
	            }
	            return m_weakTable;
	        }
	    }

	    public static global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken add_CollectionChanged(
	        global::System.Collections.Specialized.INotifyCollectionChanged _this,
	        global::System.Collections.Specialized.NotifyCollectionChangedEventHandler value)
	    {
	        // Need to call GetValue (GetOrCreateValue doesn't work without reflection)
	        global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.Collections.Specialized.NotifyCollectionChangedEventHandler> table = WeakTable.GetValue(_this, CreateTableForINotifyCollectionChanged);

	        global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token = table.AddEventHandler(value);
	        _this.CollectionChanged += value;
	        return token;
	    }

	    public static void remove_CollectionChanged(
	         global::System.Collections.Specialized.INotifyCollectionChanged _this,
	        global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token)
	    {
	        // Need to call GetValue (GetOrCreateValue doesn't work without reflection)
	        global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.Collections.Specialized.NotifyCollectionChangedEventHandler> table = WeakTable.GetValue(_this, CreateTableForINotifyCollectionChanged);

	        global::System.Collections.Specialized.NotifyCollectionChangedEventHandler handler = global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationHelpers.ExtractHandler(table, token);
	        if (handler != null)
	        {
	            _this.CollectionChanged -= handler;
	        }
	    }

	    private static global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.Collections.Specialized.NotifyCollectionChangedEventHandler> CreateTableForINotifyCollectionChanged(System.Collections.Specialized.INotifyCollectionChanged notifyCollectionChanged)
	    {
	        return new global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.Collections.Specialized.NotifyCollectionChangedEventHandler>();
	    }
	}


	public static class NotifyPropertyChangedToWinRTAdapter 
	{
	    private static global::System.Runtime.CompilerServices.ConditionalWeakTable<System.ComponentModel.INotifyPropertyChanged, global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.ComponentModel.PropertyChangedEventHandler>> m_weakTable;

	    private static global::System.Runtime.CompilerServices.ConditionalWeakTable<System.ComponentModel.INotifyPropertyChanged, global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.ComponentModel.PropertyChangedEventHandler>> WeakTable
	    {
	        get
	        {
	            if (m_weakTable == null)
	            {
	                global::System.Runtime.CompilerServices.ConditionalWeakTable<System.ComponentModel.INotifyPropertyChanged, global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.ComponentModel.PropertyChangedEventHandler>> weakTable
	                    = new global::System.Runtime.CompilerServices.ConditionalWeakTable<System.ComponentModel.INotifyPropertyChanged, global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.ComponentModel.PropertyChangedEventHandler>>();
	                global::System.Threading.Interlocked.CompareExchange(ref m_weakTable, weakTable, null);

	            }
	            return m_weakTable;
	        }
	    }

	    public static global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken add_PropertyChanged(
	        global::System.ComponentModel.INotifyPropertyChanged _this,
	        global::System.ComponentModel.PropertyChangedEventHandler value)
	    {
	        // Need to call GetValue (GetOrCreateValue doesn't work without reflection)
	        global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.ComponentModel.PropertyChangedEventHandler> table = WeakTable.GetValue(_this, CreateTableForINotifyPropertyChanged);

	        global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token = table.AddEventHandler(value);
	        _this.PropertyChanged += value;
	        return token;
	    }

	    public static void remove_PropertyChanged(
	         global::System.ComponentModel.INotifyPropertyChanged _this,
	        global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token)
	    {
	        // Need to call GetValue (GetOrCreateValue doesn't work without reflection)
	        global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.ComponentModel.PropertyChangedEventHandler> table = WeakTable.GetValue(_this, CreateTableForINotifyPropertyChanged);

	        global::System.ComponentModel.PropertyChangedEventHandler handler = global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationHelpers.ExtractHandler(table, token);
	        if (handler != null)
	        {
	            _this.PropertyChanged -= handler;
	        }
	    }

	    private static global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.ComponentModel.PropertyChangedEventHandler> CreateTableForINotifyPropertyChanged(System.ComponentModel.INotifyPropertyChanged notifyCollectionChanged)
	    {
	        return new global::System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<System.ComponentModel.PropertyChangedEventHandler>();
	    }

	}

	// Specialization: GetMany,string
	public static class ListToVectorAdapter 
	{
	    // T GetAt(uint index)
	    public static T GetAt<T>(
	        global::System.Collections.Generic.IList<T> _this,
	        uint index)
	    {
	        EnsureIndexInt32(index);

	        try
	        {
	            return _this[(int)index];
	        }
	        catch (System.ArgumentOutOfRangeException ex)
	        {
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_BOUNDS);
	            throw;
	        }
	    }

	    // uint Size { get }
	    public static uint get_Size<T>(
	        global::System.Collections.Generic.IList<T> _this
	        )
	    {
	        return (uint)_this.Count;
	    }

	    // IVectorView<T> GetView()
	    public static global::System.Collections.Generic.IReadOnlyList<T> GetView<T>(
	        global::System.Collections.Generic.IList<T> _this
	        )
	    {
	        //Contract.Assert(_this != null);

	        // Note: This list is not really read-only - you could QI for a modifiable
	        // list.  We gain some perf by doing this.  We believe this is acceptable.
	        global::System.Collections.Generic.IReadOnlyList<T> roList = _this as global::System.Collections.Generic.IReadOnlyList<T>;
	        if (roList == null)
	        {
	            roList = new global::System.Collections.ObjectModel.ReadOnlyCollection<T>(_this);
	        }
	        return roList;
	    }

	    // bool IndexOf(T value, out uint index)
	    public static bool IndexOf<T>(
	        global::System.Collections.Generic.IList<T> _this,
	        T value,
	        out uint index)
	    {
	        int ind = _this.IndexOf(value);

	        if (-1 == ind)
	        {
	            index = 0;
	            return false;
	        }

	        index = (uint)ind;
	        return true;
	    }

	    // void SetAt(uint index, T value)
	    public static void SetAt<T>(
	        global::System.Collections.Generic.IList<T> _this,
	        uint index,
	        T value)
	    {
	        EnsureIndexInt32(index);

	        try
	        {
	            _this[(int)index] = value;
	        }
	        catch (System.ArgumentOutOfRangeException ex)
	        {
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_BOUNDS);
	            throw;
	        }
	    }

	    // void InsertAt(uint index, T value)
	    public static void InsertAt<T>(
	        global::System.Collections.Generic.IList<T> _this,
	        uint index,
	        T value)
	    {

	        // Inserting at an index one past the end of the list is equivalent to appending
	        // so we need to ensure that we're within (0, count + 1).
	        EnsureIndexInt32(index);

	        try
	        {
	            _this.Insert((int)index, value);
	        }
	        catch (System.ArgumentOutOfRangeException ex)
	        {
	            // Change error code to match what WinRT expects
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_BOUNDS);
	            throw;
	        }
	    }

	    // void RemoveAt(uint index)
	    public static void RemoveAt<T>(
	        global::System.Collections.Generic.IList<T> _this,
	        uint index)
	    {
	        EnsureIndexInt32(index);

	        try
	        {
	            _this.RemoveAt((int)index);
	        }
	        catch (System.ArgumentOutOfRangeException ex)
	        {
	            // Change error code to match what WinRT expects
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_BOUNDS);
	            throw;
	        }
	    }

	    // void Append(T value)
	    public static void Append<T>(
	        global::System.Collections.Generic.IList<T> _this,
	        T value)
	    {
	        _this.Add(value);
	    }

	    // void RemoveAtEnd()
	    public static void RemoveAtEnd<T>(
	        global::System.Collections.Generic.IList<T> _this)
	    {
	        uint size = (uint)_this.Count;
	        
	        if (size == 0)
	        {
	            InvalidOperationException ex = new InvalidOperationException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_CannotRemoveFromEmptyCollection));

	            // Change error code to match what WinRT expects
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_BOUNDS);
	            throw ex;
	        }

	        RemoveAt<T>(_this, size - 1);
	    }

	    // void Clear()
	    public static void Clear<T>(
	        global::System.Collections.Generic.IList<T> _this)
	    {
	        _this.Clear();
	    }

	    // uint GetMany(uint startIndex, T[] items)
	    public static uint GetMany<T>(
	        global::System.Collections.Generic.IList<T> _this,
	        uint startIndex,
	        T[] items)
	    {
	        return GetManyHelper<T>(_this, startIndex, items);
	    }

	    // @TODO - Weird shared CCW support that I don't really understand. Get rid of this.
	    public static uint GetMany_string(
	        global::System.Collections.Generic.IList<string> _this,
	        uint startIndex,
	        string[] items)
	    {
	        return GetManyHelper<string>(_this, startIndex, items);
	    }

	    // void ReplaceAll(T[] items)
	    public static void ReplaceAll<T>(
	        global::System.Collections.Generic.IList<T> _this,
	        T[] items)
	    {
	        _this.Clear();

	        if (items != null)
	        {
	            for (int i = 0; i < items.Length; i ++)
	            {
	                _this.Add(items[i]);
	            }
	        }
	    }

	    // Helpers:

	    private static void EnsureIndexInt32(uint index)
	    {
	        // We use '<=' and not '<' becasue Int32.MaxValue == index would imply
	        // that Size > Int32.MaxValue:
	        if (((uint)System.Int32.MaxValue) <= index)
	        {
	            throw global::McgInterop.Helpers.NewException_ArgumentOutOfRangeException_index_BOUNDS();
	        }
	    }

	    private static uint GetManyHelper<T>(global::System.Collections.Generic.IList<T> sourceList, uint startIndex, T[] items)
	    {
	        int count = sourceList.Count;

	        // Calling GetMany with a start index equal to the size of the list should always
	        // return 0 elements, regardless of the input item size
	        if (startIndex == count)
	        {
	            return 0;
	        }

	        if(startIndex > (uint)count)
	        {
	            throw global::McgInterop.Helpers.NewException_ArgumentOutOfRangeException_index_BOUNDS();
	        }

	        EnsureIndexInt32(startIndex);

	        if (items == null)
	        {
	            return 0;
	        }

	        uint itemCount = global::System.Math.Min((uint)items.Length, (uint) count - startIndex);
	        
	        for (uint i = 0; i < itemCount; ++i)
	        {
	            items[i] = sourceList[(int)(i + startIndex)];
	        }

	        return itemCount;
	    }
	}

	public sealed class CLRIKeyValuePairImpl<K, V> : 
	    global::System.Runtime.InteropServices.BoxedKeyValuePair, 
	    global::Windows.Foundation.Collections.IKeyValuePair<K, V>
	{
	    private global::System.Collections.Generic.KeyValuePair<K, V> _pair;

	    public CLRIKeyValuePairImpl(ref global::System.Collections.Generic.KeyValuePair<K, V> pair)
	    {
	        _pair = pair;
	    }

	    // IKeyValuePair<K, V> implementation
	    //[Pure]
	    [global::System.Runtime.InteropServices.McgAccessor(global::System.Runtime.InteropServices.McgAccessorKind.PropertyGet, "Key")]
	    public K get_Key()
	    {
	        return _pair.Key;
	    }

	    //[Pure]
	    [global::System.Runtime.InteropServices.McgAccessor(global::System.Runtime.InteropServices.McgAccessorKind.PropertyGet, "Value")]
	    public V get_Value()
	    {
	        return _pair.Value;
	    }

	    public override object GetTarget()
	    {
	        return (object) _pair;
	    }

	    // Called by public object McgModule.Box(object obj, int boxingIndex) after allocating instance
	    public override object Initialize(object pair)
	    {
	        _pair = (global::System.Collections.Generic.KeyValuePair<K, V>)pair;

	        return this;
	    }

	    // We call this method from ComInterop.cs in the Unboxing code.
	    public static object Unbox(object wrapper)
	    {
	        CLRIKeyValuePairImpl<K, V> reference = wrapper as CLRIKeyValuePairImpl<K, V>;

	        if (reference != null)
	        {
	            return reference._pair;
	        }
	        else
	        {
	            // We could just have the native IKeyValuePair in which case we simply return wrapper as IKeyValuePair.

	            global::Windows.Foundation.Collections.IKeyValuePair<K, V> iPair = wrapper as global::Windows.Foundation.Collections.IKeyValuePair<K, V>;
	            return new System.Collections.Generic.KeyValuePair<K, V>(iPair.get_Key(), iPair.get_Value());
	        }
	    }

	    public override string ToString()
	    {
	        return _pair.ToString();
	    }
	}


	public sealed class CLRIKeyValuePairArrayImpl<K, V> : global::System.Runtime.InteropServices.BoxedKeyValuePair
	{
	    private object _pairs;

	    // Called by public object McgModule.Box(object obj, int boxingIndex) after allocating instance
	    public override object Initialize(object pairs)
	    {
	        _pairs = pairs;

	        global::System.Collections.Generic.KeyValuePair<K, V>[] unboxedPairArray = pairs as global::System.Collections.Generic.KeyValuePair<K, V>[];

	        // Contract.Requires(unboxedPairArray != null);
	        object[] boxedKeyValuePairs = new object[unboxedPairArray.Length];
	        
	        for (int i = 0; i < unboxedPairArray.Length; i++)
	        {
	            boxedKeyValuePairs[i] = new CLRIKeyValuePairImpl<K, V>(ref unboxedPairArray[i]);
	        }

	        // Lets create the IReferenceArrayImpl of the type.
	        return new ReferenceArrayImpl<object>(boxedKeyValuePairs, global::Windows.Foundation.PropertyType.InspectableArray);
	    }

	    public override object GetTarget()
	    {
	        return (object) _pairs;
	    }
	}

	public static class DictionaryToMapAdapter 
	{
	    // V Lookup(K key)
	    public static V Lookup<K, V>(
	        global::System.Collections.Generic.IDictionary<K,V> _this, 
	        K key)
	    {
	        try
	        {
	            return _this[key];
	        }
	        catch(KeyNotFoundException ex)
	        {
	            // Change error code to match what WinRT expects
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_BOUNDS);
	            throw;
	        }
	    }

	    // uint Size { get }
	    public static uint get_Size<K, V>(
	        global::System.Collections.Generic.IDictionary<K,V> _this
	        )
	    {
	        return (uint)_this.Count;
	    }

	    // bool HasKey(K key)
	    public static bool HasKey<K, V>(
	        global::System.Collections.Generic.IDictionary<K, V> _this, 
	        K key)
	    {
	        return _this.ContainsKey(key);
	    }

	    // IMapView<K, V> GetView()
	    public static global::System.Collections.Generic.IReadOnlyDictionary<K, V> GetView<K, V>(
	        global::System.Collections.Generic.IDictionary<K,V> _this
	        )
	    {
	        //Contract.Assert(_this != null);

	        // Note: This dictionary is not really read-only - you could QI for a modifiable
	        // dictionary.  We gain some perf by doing this.  We believe this is acceptable.
	        global::System.Collections.Generic.IReadOnlyDictionary<K, V> roDictionary = _this as global::System.Collections.Generic.IReadOnlyDictionary<K, V>;
	        
	        if (roDictionary == null)
	        {
	            roDictionary = new global::System.Collections.ObjectModel.ReadOnlyDictionary<K, V>(_this);
	        }
	        
	        return roDictionary;
	    }

	    // bool Insert(K key, V value)
	    public static bool Insert<K, V>(global::System.Collections.Generic.IDictionary<K, V> _this, 
	        K key, 
	        V value)
	    {
	        bool replacing = _this.ContainsKey(key);
	        _this[key] = value;
	        return replacing;
	    }

	    // void Remove(K key)
	    public static void Remove<K, V>(
	        global::System.Collections.Generic.IDictionary<K, V> _this, 
	        K key)
	    {
	        if (! _this.Remove(key))
	        {
	            throw global::McgInterop.Helpers.NewException_CollectionsGeneric_KeyNotFoundException_BOUNDS();
	        }
	    }

	    // void Clear()
	    public static void Clear<K, V>(
	        global::System.Collections.Generic.IDictionary<K,V> _this
	        )
	    {
	        _this.Clear();
	    }
	}


	public sealed class DictionaryKeyCollection<TKey, TValue> : global::System.Collections.Generic.ICollection<TKey>
	{
	    private readonly global::System.Collections.Generic.IDictionary<TKey, TValue> dictionary;

	    public DictionaryKeyCollection(System.Collections.Generic.IDictionary<TKey, TValue> dictionary)
	    {
	        if (dictionary == null)
	            throw global::McgInterop.Helpers.NewException_ArgumentNullException_dictionary();

	        this.dictionary = dictionary;
	    }

	    public void CopyTo(TKey[] array, int index)
	    {
	        global::System.Exception error = global::McgInterop.McgHelpers.CheckCopyTo(dictionary.Count, array, index);

	        if (error != null)
	        {
	            throw error;
	        }

	        int i = index;
	        foreach (global::System.Collections.Generic.KeyValuePair<TKey, TValue> mapping in dictionary)
	        {
	            array[i++] = mapping.Key;
	        }
	    }

	    public int Count
	    {
	        get { return dictionary.Count; }
	    }

	    bool global::System.Collections.Generic.ICollection<TKey>.IsReadOnly
	    {
	        get { return true; }
	    }

	    void global::System.Collections.Generic.ICollection<TKey>.Add(TKey item)
	    {
	        throw new NotSupportedException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_KeyCollectionSet));
	    }

	    void global::System.Collections.Generic.ICollection<TKey>.Clear()
	    {
	        throw new NotSupportedException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_KeyCollectionSet));
	    }

	    public bool Contains(TKey item)
	    {
	        return dictionary.ContainsKey(item);
	    }

	    bool global::System.Collections.Generic.ICollection<TKey>.Remove(TKey item)
	    {
	        throw new NotSupportedException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_KeyCollectionSet));
	    }

	    global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator()
	    {
	        return ((System.Collections.Generic.IEnumerable<TKey>)this).GetEnumerator();
	    }

	    public global::System.Collections.Generic.IEnumerator<TKey> GetEnumerator()
	    {
	        return new DictionaryKeyEnumerator<TKey, TValue>(dictionary);
	    }
	}  // public class DictionaryKeyCollection<TKey, TValue>


	internal sealed class DictionaryKeyEnumerator<TKey, TValue> : global::System.Collections.Generic.IEnumerator<TKey>
	{
	    private readonly global::System.Collections.Generic.IDictionary<TKey, TValue> dictionary;
	    private global::System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> enumeration;

	    public DictionaryKeyEnumerator(System.Collections.Generic.IDictionary<TKey, TValue> dictionary)
	    {
	        if (dictionary == null)
	            throw global::McgInterop.Helpers.NewException_ArgumentNullException_dictionary();

	        this.dictionary = dictionary;
	        this.enumeration = dictionary.GetEnumerator();
	    }

	    void global::System.IDisposable.Dispose()
	    {
	        enumeration.Dispose();
	    }

	    public bool MoveNext()
	    {
	        return enumeration.MoveNext();
	    }

	    global::System.Object global::System.Collections.IEnumerator.Current
	    {
	        get { return ((System.Collections.Generic.IEnumerator<TKey>)this).Current; }
	    }

	    public TKey Current
	    {
	        get { return enumeration.Current.Key; }
	    }

	    public void Reset()
	    {
	        enumeration = dictionary.GetEnumerator();
	    }
	}  // class DictionaryKeyEnumerator<TKey, TValue>

	internal sealed class DictionaryValueCollection<TKey, TValue> : global::System.Collections.Generic.ICollection<TValue>
	{
	    private readonly global::System.Collections.Generic.IDictionary<TKey, TValue> dictionary;

	    public DictionaryValueCollection(System.Collections.Generic.IDictionary<TKey, TValue> dictionary)
	    {
	        if (dictionary == null)
	            throw global::McgInterop.Helpers.NewException_ArgumentNullException_dictionary();

	        this.dictionary = dictionary;
	    }

	    public void CopyTo(TValue[] array, int index)
	    {
	        global::System.Exception error = global::McgInterop.McgHelpers.CheckCopyTo(dictionary.Count, array, index);

	        if (error != null)
	        {
	            throw error;
	        }

	        int i = index;
	        foreach (System.Collections.Generic.KeyValuePair<TKey, TValue> mapping in dictionary)
	        {
	            array[i++] = mapping.Value;
	        }
	    }

	    public int Count
	    {
	        get { return dictionary.Count; }
	    }

	    bool global::System.Collections.Generic.ICollection<TValue>.IsReadOnly
	    {
	        get { return true; }
	    }

	    void global::System.Collections.Generic.ICollection<TValue>.Add(TValue item)
	    {
	        throw new NotSupportedException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_ValueCollectionSet));
	    }

	    void global::System.Collections.Generic.ICollection<TValue>.Clear()
	    {
	        throw new NotSupportedException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_ValueCollectionSet));
	    }

	    public bool Contains(TValue item)
	    {
	        foreach (TValue value in this)
	            if (global::System.Runtime.InteropServices.McgMarshal.ComparerEquals<TValue>(item, value))
	                return true;
	        return false;
	    }

	    bool global::System.Collections.Generic.ICollection<TValue>.Remove(TValue item)
	    {
	        throw new NotSupportedException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_ValueCollectionSet));
	    }

	    global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator()
	    {
	        return ((System.Collections.Generic.IEnumerable<TValue>)this).GetEnumerator();
	    }

	    public global::System.Collections.Generic.IEnumerator<TValue> GetEnumerator()
	    {
	        return new DictionaryValueEnumerator<TKey, TValue>(dictionary);
	    }
	}  // public class DictionaryValueCollection<TKey, TValue>


	internal sealed class DictionaryValueEnumerator<TKey, TValue> : global::System.Collections.Generic.IEnumerator<TValue>
	{
	    private readonly global::System.Collections.Generic.IDictionary<TKey, TValue> dictionary;
	    private global::System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> enumeration;

	    public DictionaryValueEnumerator(System.Collections.Generic.IDictionary<TKey, TValue> dictionary)
	    {
	        if (dictionary == null)
	            throw global::McgInterop.Helpers.NewException_ArgumentNullException_dictionary();

	        this.dictionary = dictionary;
	        this.enumeration = dictionary.GetEnumerator();
	    }

	    void global::System.IDisposable.Dispose()
	    {
	        enumeration.Dispose();
	    }

	    public bool MoveNext()
	    {
	        return enumeration.MoveNext();
	    }

	    global::System.Object global::System.Collections.IEnumerator.Current
	    {
	        get { return ((System.Collections.Generic.IEnumerator<TValue>)this).Current; }
	    }

	    public TValue Current
	    {
	        get { return enumeration.Current.Value; }
	    }

	    public void Reset()
	    {
	        enumeration = dictionary.GetEnumerator();
	    }
	}  // class DictionaryValueEnumerator<TKey, TValue>

	public static class ReadOnlyDictionaryToMapViewAdapter 
	{
	    // V Lookup(K key)
	    public static V Lookup<K, V>(global::System.Collections.Generic.IReadOnlyDictionary<K,V> _this, K key)
	    {
	        try
	        {
	            return _this[key];
	        }
	        catch (KeyNotFoundException ex)
	        {
	            // Change error code to match what WinRT expects
	            McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.E_BOUNDS);
	            throw;
	        }
	    }

	    // uint Size { get }
	    public static uint get_Size<K,V>(global::System.Collections.Generic.IReadOnlyDictionary<K, V> _this)
	    {
	        return (uint)_this.Count;
	    }

	    // bool HasKey(K key)
	    public static bool HasKey<K, V>(
	        global::System.Collections.Generic.IReadOnlyDictionary<K,V> _this,
	        K key)
	    {
	        return _this.ContainsKey(key);
	    }

	    // void Split(out IReadOnlyDictionary<K, V> first, out IReadOnlyDictionary<K, V> second)
	    public static void Split<K, V>(global::System.Collections.Generic.IReadOnlyDictionary<K, V> _this,
	        out global::System.Collections.Generic.IReadOnlyDictionary<K, V> first,
	        out global::System.Collections.Generic.IReadOnlyDictionary<K, V> second)
	    {
	        if (_this.Count < 2)
	        {
	            first = null;
	            second = null;
	            return;
	        }

	        ConstantSplittableMap<K, V> splittableMap = _this as ConstantSplittableMap<K, V>;

	        if (splittableMap == null)
	            splittableMap = new ConstantSplittableMap<K, V>(_this);

	        splittableMap.Split(out first, out second);
	    }
	}

	// Note: One day we may make these return IReadOnlyCollection<T>
	public sealed class ReadOnlyDictionaryKeyCollection<TKey, TValue> : global::System.Collections.Generic.IEnumerable<TKey>
	{
	    private readonly global::System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> dictionary;

	    public ReadOnlyDictionaryKeyCollection(System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> dictionary)
	    {
	        if (dictionary == null)
	            throw global::McgInterop.Helpers.NewException_ArgumentNullException_dictionary(); 

	        this.dictionary = dictionary;
	    }

	    /*
	    public void CopyTo(TKey[] array, int index)
	    {
	        if (array == null)
	            throw global::McgInterop.Helpers.NewException_ArgumentNullException_array();
	        if (index < 0)
	            throw global::McgInterop.Helpers.NewException_ArgumentOutOfRangeException_index();
	        if (array.Length <= index && this.Count > 0)
	            throw new ArgumentException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_IndexOutOfArrayBounds));
	        if (array.Length - index < dictionary.Count)
	            throw new ArgumentException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_InsufficientSpaceToCopyCollection));

	        int i = index;
	        foreach (KeyValuePair<TKey, TValue> mapping in dictionary)
	        {
	            array[i++] = mapping.Key;
	        }
	    }
	        
	    public int Count {
	        get { return dictionary.Count; }
	    }

	    public bool Contains(TKey item)
	    {
	        return dictionary.ContainsKey(item);
	    }
	    */

	    global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator()
	    {
	        return ((System.Collections.Generic.IEnumerable<TKey>)this).GetEnumerator();
	    }

	    public global::System.Collections.Generic.IEnumerator<TKey> GetEnumerator()
	    {
	        return new ReadOnlyDictionaryKeyEnumerator<TKey, TValue>(dictionary);
	    }
	}  // public class ReadOnlyDictionaryKeyCollection<TKey, TValue>


	internal sealed class ReadOnlyDictionaryKeyEnumerator<TKey, TValue> : global::System.Collections.Generic.IEnumerator<TKey>
	{
	    private readonly global::System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> dictionary;
	    private global::System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> enumeration;

	    public ReadOnlyDictionaryKeyEnumerator(System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> dictionary)
	    {
	        if (dictionary == null)
	            throw global::McgInterop.Helpers.NewException_ArgumentNullException_dictionary(); 

	        this.dictionary = dictionary;
	        this.enumeration = dictionary.GetEnumerator();
	    }

	    void global::System.IDisposable.Dispose()
	    {
	        enumeration.Dispose();
	    }

	    public bool MoveNext()
	    {
	        return enumeration.MoveNext();
	    }

	    global::System.Object global::System.Collections.IEnumerator.Current
	    {
	        get { return ((System.Collections.Generic.IEnumerator<TKey>)this).Current; }
	    }

	    public TKey Current
	    {
	        get { return enumeration.Current.Key; }
	    }

	    public void Reset()
	    {
	        enumeration = dictionary.GetEnumerator();
	    }
	}  // class ReadOnlyDictionaryKeyEnumerator<TKey, TValue>


	internal sealed class ReadOnlyDictionaryValueCollection<TKey, TValue> : global::System.Collections.Generic.IEnumerable<TValue>
	{
	    private readonly global::System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> dictionary;

	    public ReadOnlyDictionaryValueCollection(System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> dictionary)
	    {
	        if (dictionary == null)
	            throw global::McgInterop.Helpers.NewException_ArgumentNullException_dictionary(); 

	        this.dictionary = dictionary;
	    }

	    /*
	    public void CopyTo(TValue[] array, int index)
	    {
	        if (array == null)
	            throw global::McgInterop.Helpers.NewException_ArgumentNullException_array();
	        if (index < 0)
	            throw global::McgInterop.Helpers.NewException_ArgumentOutOfRangeException_index();
	        if (array.Length <= index && this.Count > 0)
	            throw new ArgumentException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_IndexOutOfArrayBounds));
	        if (array.Length - index < dictionary.Count)
	            throw new ArgumentException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_InsufficientSpaceToCopyCollection));

	        int i = index;
	        foreach (KeyValuePair<TKey, TValue> mapping in dictionary)
	        {
	            array[i++] = mapping.Value;
	        }
	    }

	    public int Count {
	        get { return dictionary.Count; }
	    }

	    public bool Contains(TValue item)
	    {
	        EqualityComparer<TValue> comparer = EqualityComparer<TValue>.Default;
	        foreach (TValue value in this)
	            if (comparer.Equals(item, value))
	                return true;
	        return false;
	    }
	    */

	    global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator()
	    {
	        return ((System.Collections.Generic.IEnumerable<TValue>)this).GetEnumerator();
	    }

	    public global::System.Collections.Generic.IEnumerator<TValue> GetEnumerator()
	    {
	        return new ReadOnlyDictionaryValueEnumerator<TKey, TValue>(dictionary);
	    }
	}  // public class ReadOnlyDictionaryValueCollection<TKey, TValue>


	internal sealed class ReadOnlyDictionaryValueEnumerator<TKey, TValue> : global::System.Collections.Generic.IEnumerator<TValue>
	{
	    private readonly global::System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> dictionary;
	    private global::System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> enumeration;

	    public ReadOnlyDictionaryValueEnumerator(System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> dictionary)
	    {
	        if (dictionary == null)
	            throw global::McgInterop.Helpers.NewException_ArgumentNullException_dictionary(); 

	        this.dictionary = dictionary;
	        this.enumeration = dictionary.GetEnumerator();
	    }

	    void global::System.IDisposable.Dispose()
	    {
	        enumeration.Dispose();
	    }

	    public bool MoveNext()
	    {
	        return enumeration.MoveNext();
	    }

	    global::System.Object global::System.Collections.IEnumerator.Current
	    {
	        get { return ((System.Collections.Generic.IEnumerator<TValue>)this).Current; }
	    }

	    public TValue Current
	    {
	        get { return enumeration.Current.Value; }
	    }

	    public void Reset()
	    {
	        enumeration = dictionary.GetEnumerator();
	    }
	}  // class ReadOnlyDictionaryValueEnumerator<TKey, TValue>


	internal sealed class ConstantSplittableMap<TKey, TValue> : global::System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>, global::System.Collections.Generic.IComparer<System.Collections.Generic.KeyValuePair<TKey, TValue>>
	{
	    // Comparing key only
	    public int Compare(global::System.Collections.Generic.KeyValuePair<TKey, TValue> x, global::System.Collections.Generic.KeyValuePair<TKey, TValue> y)
	    {
	        return global::System.Collections.Generic.Comparer<TKey>.Default.Compare(x.Key, y.Key);
	    }

	    private readonly global::System.Collections.Generic.KeyValuePair<TKey, TValue>[] items;
	    private readonly int firstItemIndex;
	    private readonly int lastItemIndex;

	    internal ConstantSplittableMap(global::System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> data)
	    {
	        if (data == null)
	            throw global::McgInterop.Helpers.NewException_ArgumentNullException_data();

	        int count = data.Count;

	        this.lastItemIndex = count - 1;

	        items = new global::System.Collections.Generic.KeyValuePair<TKey, TValue>[count];

	        int i = 0;

	        foreach (global::System.Collections.Generic.KeyValuePair<TKey, TValue> kv in data)
	        {
	            items[i++] = kv;
	        }

	        global::System.Array.Sort(items, 0, items.Length, this);
	    }

	    private ConstantSplittableMap(global::System.Collections.Generic.KeyValuePair<TKey, TValue>[] items, global::System.Int32 firstItemIndex, global::System.Int32 lastItemIndex)
	    {
	        this.items = items;
	        this.firstItemIndex = firstItemIndex;
	        this.lastItemIndex = lastItemIndex;
	    }
	    
	    public int Count
	    {
	        get
	        {
	            return lastItemIndex - firstItemIndex + 1;
	        }
	    }
	    
	    // [CLSCompliant(false)]
	    public uint Size
	    {
	        get
	        {
	            return (System.UInt32)(lastItemIndex - firstItemIndex + 1);
	        }
	    }
	    
	    public TValue Lookup(TKey key)
	    {
	        int index = Find(ref key);

	        if (index < 0)
	        {
	            throw new KeyNotFoundException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_KeyNotFound));
	        }

	        return items[index].Value;
	    }
	    
	    public bool HasKey(TKey key)
	    {
	        return Find(ref key) >= 0;
	    }

	    global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator()
	    {
	        return this.GetEnumerator();
	    }

	    public global::System.Collections.Generic.IEnumerator<global::System.Collections.Generic.KeyValuePair<TKey, TValue>> GetEnumerator()
	    {
	        return new IKeyValuePairEnumerator(this.items, this.firstItemIndex, this.lastItemIndex);
	    }

	    public void Split(out global::System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> firstPartition, out global::System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> secondPartition)
	    {
	        if (Count < 2)
	        {
	            firstPartition = null;
	            secondPartition = null;
	            return;
	        }

	        int pivot = (int)(((long)firstItemIndex + (long)lastItemIndex) / (long)2);

	        firstPartition = new ConstantSplittableMap<TKey, TValue>(items, firstItemIndex, pivot);
	        secondPartition = new ConstantSplittableMap<TKey, TValue>(items, pivot + 1, lastItemIndex);
	    }

	    //#region IReadOnlyDictionary members

	    int Find(ref TKey key)
	    {
	        global::System.Collections.Generic.KeyValuePair<TKey, TValue> searchKey = new global::System.Collections.Generic.KeyValuePair<TKey, TValue>(key, default(TValue));
	        
	        return global::System.Array.BinarySearch(items, firstItemIndex, Count, searchKey, this);
	    }

	    public bool ContainsKey(TKey key)
	    {
	        return Find(ref key) >= 0;
	    }

	    public bool TryGetValue(TKey key, out TValue value)
	    {
	        int index = Find(ref key);

	        if (index < 0)
	        {
	            value = default(TValue);
	            return false;
	        }

	        value = items[index].Value;
	        return true;
	    }

	    public TValue this[TKey key]
	    {
	        get
	        {
	            return Lookup(key);
	        }
	    }

	    public global::System.Collections.Generic.IEnumerable<TKey> Keys
	    {
	        get
	        {
	            throw global::McgInterop.Helpers.NewException_NotImplementedException_NYI();
	        }
	    }

	    public global::System.Collections.Generic.IEnumerable<TValue> Values
	    {
	        get
	        {
	            throw global::McgInterop.Helpers.NewException_NotImplementedException_NYI();
	        }
	    }

	    //#endregion IReadOnlyDictionary members

	    #region IKeyValuePair Enumerator

	    internal class IKeyValuePairEnumerator : global::System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>
	    {
	        private global::System.Collections.Generic.KeyValuePair<TKey, TValue>[] _array;
	        private int _start;
	        private int _end;
	        private int _current;

	        internal IKeyValuePairEnumerator(System.Collections.Generic.KeyValuePair<TKey, TValue>[] items, int first, int end)
	        {
	            //Contract.Requires(items != null);
	            //Contract.Requires(first >= 0);
	            //Contract.Requires(end >= 0);
	            //Contract.Requires(first < items.Length);
	            //Contract.Requires(end < items.Length);

	            _array = items;
	            _start = first;
	            _end = end;
	            _current = _start - 1;
	        }

	        public bool MoveNext()
	        {
	            if (_current < _end)
	            {
	                _current++;
	                return true;
	            }

	            return false;
	        }

	        public global::System.Collections.Generic.KeyValuePair<TKey, TValue> Current
	        {
	            get
	            {
	                if (_current < _start) throw new InvalidOperationException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_EnumNotStarted));
	                if (_current > _end)   throw new InvalidOperationException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.Excep_EnumEnded));
	                //return new CLRIKeyValuePairImpl<TKey, TValue>(ref _array[_current]);
	                return _array[_current];
	            }
	        }

	        object global::System.Collections.IEnumerator.Current
	        {
	            get
	            {
	                return Current;
	            }
	        }

	        void global::System.Collections.IEnumerator.Reset()
	        {
	            _current = _start - 1;
	        }

	        public void Dispose()
	        {
	        }
	    }

	    #endregion IKeyValuePair Enumerator

	}  // internal ConstantSplittableMap<TKey, TValue>

	public class PropertyValueImpl : BoxedValue, global::Windows.Foundation.IPropertyValue
	{
	    internal PropertyValueImpl(object val, int type) : base(val, type)
	    {
	    }

	    [global::System.Runtime.InteropServices.McgAccessor(global::System.Runtime.InteropServices.McgAccessorKind.PropertyGet, "Type")]
	    public global::Windows.Foundation.PropertyType get_Type()
	    {
	        return (global::Windows.Foundation.PropertyType)m_type;
	    }

	    [global::System.Runtime.InteropServices.McgAccessor(global::System.Runtime.InteropServices.McgAccessorKind.PropertyGet, "IsNumericScalar")]
	    public bool get_IsNumericScalar()
	    {
	        return IsNumericScalarImpl((global::Windows.Foundation.PropertyType)m_type, m_data);
	    }

	    public byte GetUInt8()
	    {
	        return CoerceScalarValue<byte>(global::Windows.Foundation.PropertyType.UInt8);
	    }

	    public short GetInt16()
	    {
	        return CoerceScalarValue<short>(global::Windows.Foundation.PropertyType.Int16);
	    }

	    public ushort GetUInt16()
	    {
	        return CoerceScalarValue<ushort>(global::Windows.Foundation.PropertyType.UInt16);
	    }

	    public int GetInt32()
	    {
	        return CoerceScalarValue<int>(global::Windows.Foundation.PropertyType.Int32);
	    }

	    public uint GetUInt32()
	    {
	        return CoerceScalarValue<uint>(global::Windows.Foundation.PropertyType.UInt32);
	    }

	    public long GetInt64()
	    {
	        return CoerceScalarValue<long>(global::Windows.Foundation.PropertyType.Int64);
	    }

	    public ulong GetUInt64()
	    {
	        return CoerceScalarValue<ulong>(global::Windows.Foundation.PropertyType.UInt64);
	    }

	    public float GetSingle()
	    {
	        return CoerceScalarValue<float>(global::Windows.Foundation.PropertyType.Single);
	    }

	    public double GetDouble()
	    {
	        return CoerceScalarValue<double>(global::Windows.Foundation.PropertyType.Double);
	    }

	    public char GetChar16()
	    {
	        CheckType(global::Windows.Foundation.PropertyType.Char16);        
	        return (char)m_data;
	    }

	    public bool GetBoolean()
	    {
	        CheckType(global::Windows.Foundation.PropertyType.Boolean);
	        return (bool)m_data;
	    }

	    public string GetString()
	    {
	        return CoerceScalarValue<string>(global::Windows.Foundation.PropertyType.String);
	    }

	    public object GetInspectable()
	    {
	        CheckType(global::Windows.Foundation.PropertyType.Inspectable);
	        return m_data;
	    }

	    public global::System.Guid GetGuid()
	    {
	        return CoerceScalarValue<System.Guid>(global::Windows.Foundation.PropertyType.Guid);
	    }

	    public global::System.DateTimeOffset GetDateTime()
	    {
	        CheckType(global::Windows.Foundation.PropertyType.DateTime);
	        return (System.DateTimeOffset)m_data;
	    }

	    public global::System.TimeSpan GetTimeSpan()
	    {
	        CheckType(global::Windows.Foundation.PropertyType.TimeSpan);
	        return (System.TimeSpan)m_data;
	    }

	    public global::Windows.Foundation.Point GetPoint()
	    {
	        CheckType(global::Windows.Foundation.PropertyType.Point);
	        return (global::Windows.Foundation.Point)m_data;
	    }

	    public global::Windows.Foundation.Size GetSize()
	    {
	        CheckType(global::Windows.Foundation.PropertyType.Size);
	        return (global::Windows.Foundation.Size)m_data;
	    }

	    public global::Windows.Foundation.Rect GetRect()
	    {
	        CheckType(global::Windows.Foundation.PropertyType.Rect);
	        return (global::Windows.Foundation.Rect)m_data;
	    }

	    public void GetUInt8Array(out byte[] array)
	    {
	        array = CoerceArrayValue<byte>(global::Windows.Foundation.PropertyType.UInt8Array);
	    }

	    public void GetInt16Array(out short[] array)
	    {
	        array = CoerceArrayValue<short>(global::Windows.Foundation.PropertyType.Int16Array);
	    }

	    public void GetUInt16Array(out ushort[] array)
	    {
	        array = CoerceArrayValue<ushort>(global::Windows.Foundation.PropertyType.UInt16Array);
	    }

	    public void GetInt32Array(out int[] array)
	    {
	        array = CoerceArrayValue<int>(global::Windows.Foundation.PropertyType.Int32Array);
	    }

	    public void GetUInt32Array(out uint[] array)
	    {
	        array = CoerceArrayValue<uint>(global::Windows.Foundation.PropertyType.UInt32Array);
	    }

	    public void GetInt64Array(out long[] array)
	    {
	        array = CoerceArrayValue<long>(global::Windows.Foundation.PropertyType.Int64Array);
	    }

	    public void GetUInt64Array(out ulong[] array)
	    {
	        array = CoerceArrayValue<ulong>(global::Windows.Foundation.PropertyType.UInt64Array);
	    }

	    public void GetSingleArray(out float[] array)
	    {
	        array = CoerceArrayValue<float>(global::Windows.Foundation.PropertyType.SingleArray);
	    }

	    public void GetDoubleArray(out double[] array)
	    {
	        array = CoerceArrayValue<double>(global::Windows.Foundation.PropertyType.DoubleArray);
	    }

	    public void GetChar16Array(out char[] array)
	    {
	        CheckType(global::Windows.Foundation.PropertyType.Char16Array);
	        array = (char[])m_data;
	    }

	    public void GetBooleanArray(out bool[] array)
	    {
	        CheckType(global::Windows.Foundation.PropertyType.BooleanArray);
	        array = (bool[])m_data;
	    }

	    public void GetStringArray(out string[] array)
	    {
	        array = CoerceArrayValue<string>(global::Windows.Foundation.PropertyType.StringArray);
	    }

	    public void GetInspectableArray(out object[] array)
	    {
	        CheckType(global::Windows.Foundation.PropertyType.InspectableArray);
	        array = (object[])m_data;
	    }

	    public void GetGuidArray(out global::System.Guid[] array)
	    {
	        array = CoerceArrayValue<System.Guid>(global::Windows.Foundation.PropertyType.GuidArray);
	    }

	    public void GetDateTimeArray(out global::System.DateTimeOffset[] array)
	    {
	        CheckType(global::Windows.Foundation.PropertyType.DateTimeArray);
	        array = (System.DateTimeOffset[])m_data;
	    }

	    public void GetTimeSpanArray(out global::System.TimeSpan[] array)
	    {
	        CheckType(global::Windows.Foundation.PropertyType.TimeSpanArray);
	        array = (System.TimeSpan[])m_data;
	    }

	    public void GetPointArray(out global::Windows.Foundation.Point[] array)
	    {
	        CheckType(global::Windows.Foundation.PropertyType.PointArray);
	        array = (global::Windows.Foundation.Point[])m_data;
	    }

	    public void GetSizeArray(out global::Windows.Foundation.Size[] array)
	    {
	        CheckType(global::Windows.Foundation.PropertyType.SizeArray);
	        array = (global::Windows.Foundation.Size[])m_data;
	    }

	    public void GetRectArray(out global::Windows.Foundation.Rect[] array)
	    {
	        CheckType(global::Windows.Foundation.PropertyType.RectArray);
	        array = (global::Windows.Foundation.Rect[])m_data;
	    }

	    private T[] CoerceArrayValue<T>(global::Windows.Foundation.PropertyType unboxType)
	    {
	        // If we contain the type being looked for directly, then take the fast-path
	        if (m_type == (int) unboxType)
	        {
	            return (T[])m_data;
	        }

	        // Make sure we have an array to begin with
	        global::System.Array dataArray = m_data as global::System.Array;
	        
	        if (dataArray == null)
	        {
	            throw CreateExceptionForInvalidCast((global::Windows.Foundation.PropertyType)m_type, unboxType);
	        }

	        // Array types are 1024 larger than their equivilent scalar counterpart
	        if ((m_type <= 1024) || ((int) unboxType <= 1024))
	        {
	            throw CreateExceptionForInvalidCast((global::Windows.Foundation.PropertyType)m_type, unboxType);
	        }

	        global::Windows.Foundation.PropertyType scalarType = (global::Windows.Foundation.PropertyType)(m_type - 1024);
	        global::Windows.Foundation.PropertyType unboxTypeT = unboxType - 1024;

	        // If we do not have the correct array type, then we need to convert the array element-by-element
	        // to a new array of the requested type
	        T[] coercedArray = new T[dataArray.Length];
	        
	        for (int i = 0; i < dataArray.Length; ++i)
	        {
	            coercedArray[i] = (T)CoerceScalarValue(scalarType, dataArray.GetValue(i), unboxTypeT);
	        }

	        return coercedArray;
	    }

	    [global::System.Runtime.CompilerServices.MethodImplAttribute(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
	    private T CoerceScalarValue<T>(global::Windows.Foundation.PropertyType unboxType)
	    {
	        object result = m_data;

	        // If we are just a boxed version of the requested type, then take the fast path out
	        if (m_type != (int) unboxType)
	        {
	            result = CoerceScalarValue((global::Windows.Foundation.PropertyType)m_type, result, unboxType);
	        }

	        return (T) result;
	    }

	    static private object CoerceScalarValue(global::Windows.Foundation.PropertyType type, object value, global::Windows.Foundation.PropertyType unboxType)
	    {
	        // If the property type is neither one of the coercable numeric types nor IInspectable, we
	        // should not attempt coersion, even if the underlying value is technically convertable
	        if ((type == global::Windows.Foundation.PropertyType.Guid) && (unboxType == global::Windows.Foundation.PropertyType.String))
	        {
	            // String <--> Guid is allowed
	            return ((System.Guid)value).ToString();
	        }
	        else if ((type == global::Windows.Foundation.PropertyType.String) && (unboxType == global::Windows.Foundation.PropertyType.Guid))
	        {
	            global::System.Guid result;
	            
	            if (System.Guid.TryParse((string)value, out result))
	            {
	                return result;
	            }
	        }
	        else if (type == global::Windows.Foundation.PropertyType.Inspectable)
	        {
	            // If the property type is IInspectable, and we have a nested IPropertyValue, then we need
	            // to pass along the request to coerce the value.
	            global::Windows.Foundation.IPropertyValue ipv = value as global::Windows.Foundation.IPropertyValue;

	            if (ipv != null)
	            {
	                object result = ReferenceUtility.GetWellKnownScalar(ipv, unboxType);

	                if (result != null)
	                {
	                    return result;
	                }

	                //T in coersion function wasn't understood as a type that can be coerced - make sure that CoerceScalarValue and NumericScalarTypes are in sync
	                global::McgInterop.McgCoreHelpers.Assert(false);
	            }
	        }

	        //
	        // Let Convert handle all possible conversions - this include 
	        // 1. string - which desktop code accidentally allowed
	        // 2. object (IInspectable)
	        // 
	        try
	        {
	            switch (unboxType)
	            {
	                case global::Windows.Foundation.PropertyType.UInt8:
	                    return global::System.Convert.ToByte(value);

	                case global::Windows.Foundation.PropertyType.Int16:
	                    return global::System.Convert.ToInt16(value);

	                case global::Windows.Foundation.PropertyType.UInt16:
	                    return global::System.Convert.ToUInt16(value);

	                case global::Windows.Foundation.PropertyType.Int32:
	                    return global::System.Convert.ToInt32(value);

	                case global::Windows.Foundation.PropertyType.UInt32:
	                    return global::System.Convert.ToUInt32(value);

	                case global::Windows.Foundation.PropertyType.Int64:
	                    return global::System.Convert.ToInt64(value);

	                case global::Windows.Foundation.PropertyType.UInt64:
	                    return global::System.Convert.ToUInt64(value);

	                case global::Windows.Foundation.PropertyType.Single:
	                    return global::System.Convert.ToSingle(value);

	                case global::Windows.Foundation.PropertyType.Double:
	                    return global::System.Convert.ToDouble(value);

	                default:
	                    break;
	            }
	        }
	        catch (System.FormatException)
	        {
	            throw CreateExceptionForInvalidCoersion(type, value, unboxType, global::McgInterop.McgHelpers.__HResults.TYPE_E_TYPEMISMATCH);
	        }
	        catch (System.InvalidCastException)
	        {
	            throw CreateExceptionForInvalidCoersion(type, value, unboxType, global::McgInterop.McgHelpers.__HResults.TYPE_E_TYPEMISMATCH);
	        }
	        catch (System.OverflowException)
	        {
	            throw CreateExceptionForInvalidCoersion(type, value, unboxType, global::McgInterop.McgHelpers.__HResults.DISP_E_OVERFLOW);
	        }

	        throw CreateExceptionForInvalidCast(type, unboxType);
	    }

	    private static bool IsNumericScalarImpl(global::Windows.Foundation.PropertyType type, object data)
	    {
	        switch (type)
	        {
	            case global::Windows.Foundation.PropertyType.UInt8:
	            case global::Windows.Foundation.PropertyType.Int16:
	            case global::Windows.Foundation.PropertyType.UInt16:
	            case global::Windows.Foundation.PropertyType.Int32:
	            case global::Windows.Foundation.PropertyType.UInt32:
	            case global::Windows.Foundation.PropertyType.Int64:
	            case global::Windows.Foundation.PropertyType.UInt64:
	            case global::Windows.Foundation.PropertyType.Single:
	            case global::Windows.Foundation.PropertyType.Double:
	                return true;

	            default:
	                return McgMarshal.IsEnum(data);
	        }
	    }

	    private void CheckType(global::Windows.Foundation.PropertyType unboxType)
	    {
	        if (this.get_Type() != unboxType)
	        {
	            throw CreateExceptionForInvalidCast(this.get_Type(), unboxType);
	        }
	    }

	    private static global::System.InvalidCastException CreateExceptionForInvalidCast(
	        global::Windows.Foundation.PropertyType type, 
	        global::Windows.Foundation.PropertyType unboxType)
	    {
	        global::System.InvalidCastException ex = new global::System.InvalidCastException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.PropertyValue_InvalidCast, type, unboxType));
	        McgMarshal.SetExceptionErrorCode(ex, global::McgInterop.McgHelpers.__HResults.TYPE_E_TYPEMISMATCH);
	        return ex;
	    }


	    private static global::System.InvalidCastException CreateExceptionForInvalidCoersion(
	        global::Windows.Foundation.PropertyType type,
	        object value,
	        global::Windows.Foundation.PropertyType unboxType,
	        int hr)
	    {
	        InvalidCastException ex = new InvalidCastException(global::Mcg.System.SR.GetString(global::Mcg.System.SR.PropertyValue_InvalidCoersion, type, value, unboxType));
	        McgMarshal.SetExceptionErrorCode(ex, hr);
	        return ex;
	    }
	}

	/// <summary>
	/// A managed wrapper for IPropertyValue and IReference<T>
	/// </summary>
	[global::System.Runtime.CompilerServices.DependencyReductionRootAttribute]
	public class ReferenceImpl<T> : PropertyValueImpl, global::Windows.Foundation.IReference<T>
	{
	    private T m_value;

	    public ReferenceImpl(T data, int type)
	        : base(data, type)
	    {
	        m_unboxed = true;
	        m_value = data;
	    }

	    internal ReferenceImpl(T data, global::Windows.Foundation.PropertyType type)
	        : base(data, (int)type)
	    {
	        m_unboxed = true;
	        m_value = data;
	    }

	    [global::System.Runtime.InteropServices.McgAccessor(global::System.Runtime.InteropServices.McgAccessorKind.PropertyGet, "Value")]
	    public T get_Value()
	    {
	        if (! m_unboxed)
	        {
	            m_value = (T) m_data;
	            m_unboxed = true;
	        }

	        return m_value;
	    }
	}


	public class ReferenceArrayImplBase : 
	    PropertyValueImpl, 
	    global::System.Collections.IList, 
	    global::System.Collections.Generic.IEnumerable<object>,
	    global::System.Runtime.InteropServices.ICustomQueryInterface
	{
	    // pinterface({faa585ea-6214-4217-afda-7f46de5869b3};cinterface(IInspectable))
	    internal static global::System.Guid IID_IIterableOfObject = 
	        new global::System.Guid(153846939, 24753, 21182, 0xA4, 0x4A, 0x6F, 0xE8, 0xE9, 0x33, 0xCB, 0xE4);

	    private global::System.Collections.IList _list;
	    private global::System.Collections.Generic.IEnumerable<object> _enumerableOfObject;

	    public override void Initialize(object val, int type)
	    {
	        m_data = val;
	        m_type = (short) type;

	        // This should not fail but I'm making a cast here anyway just in case 
	        // we have a bug or there is a runtime failure
	        _list = (System.Collections.IList) val;

	        // Not every array implements IEnumerable<Object>
	        _enumerableOfObject = val as global::System.Collections.Generic.IEnumerable<object>;
	    }

	    internal ReferenceArrayImplBase(object data, global::Windows.Foundation.PropertyType type) : base(data, (int) type)
	    {
	        Initialize(data, (int) type);
	    }

	    //
	    // Customize QI behavior:
	    // If this array type doesn't implement IEnumerable<Object>, reject IIterable<Object>
	    //
	    global::System.Runtime.InteropServices.CustomQueryInterfaceResult ICustomQueryInterface.GetInterface(ref global::System.Guid iid, out global::System.IntPtr ppv)
	    {
	        ppv = default(global::System.IntPtr);

	        if (global::System.Runtime.InteropServices.McgMarshal.GuidEquals(ref iid, ref IID_IIterableOfObject))
	        {
	            if (_enumerableOfObject == null)
	            {
	                // This array type doesn't actually support IEnumerable<Object>
	                // Reject the QI
	                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Failed;
	            }
	        }

	        return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
	    }

	    //
	    // IEnumerable methods. Used by data-binding in Jupiter when you try to data bind
	    // against a managed array
	    //
	    global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator()
	    {
	        return ((System.Collections.IEnumerable)_list).GetEnumerator();
	    }

	    //
	    // IEnumerable<object> methods. We need this because global::System.Array implement this (implicitly) if it is castable to object[]
	    //
	    global::System.Collections.Generic.IEnumerator<object> global::System.Collections.Generic.IEnumerable<object>.GetEnumerator()
	    {
	        return _enumerableOfObject.GetEnumerator();
	    }

	    //
	    // IList & ICollection methods. 
	    // This enables two-way data binding and index access in Jupiter
	    //
	    object global::System.Collections.IList.this[int index]
	    {
	        get
	        {
	            return _list[index];
	        }

	        set
	        {
	            _list[index] = value;
	        }
	    }

	    int global::System.Collections.IList.Add(object value)
	    {
	        return _list.Add(value);
	    }

	    bool global::System.Collections.IList.Contains(object value)
	    {
	        return _list.Contains(value);
	    }

	    void global::System.Collections.IList.Clear()
	    {
	        _list.Clear();
	    }

	    bool global::System.Collections.IList.IsReadOnly
	    {
	        get
	        {
	            return _list.IsReadOnly;
	        }
	    }

	    bool global::System.Collections.IList.IsFixedSize
	    {
	        get
	        {
	            return _list.IsFixedSize;
	        }
	    }

	    int global::System.Collections.IList.IndexOf(object value)
	    {
	        return _list.IndexOf(value);
	    }

	    void global::System.Collections.IList.Insert(int index, object value)
	    {
	        _list.Insert(index, value);
	    }

	    void global::System.Collections.IList.Remove(object value)
	    {
	        _list.Remove(value);
	    }

	    void global::System.Collections.IList.RemoveAt(int index)
	    {
	        _list.RemoveAt(index);
	    }

	    void global::System.Collections.ICollection.CopyTo(System.Array array, int index)
	    {
	        _list.CopyTo(array, index);
	    }

	    int global::System.Collections.ICollection.Count
	    {
	        get
	        {
	            return _list.Count;
	        }
	    }

	    object global::System.Collections.ICollection.SyncRoot
	    {
	        get
	        {
	            return _list.SyncRoot;
	        }
	    }

	    bool global::System.Collections.ICollection.IsSynchronized
	    {
	        get
	        {
	            return _list.IsSynchronized;
	        }
	    }
	}

	/// <summary>
	/// A managed wrapper of IReferenceArray<T>
	/// </summary>
	public sealed class ReferenceArrayImpl<T> : ReferenceArrayImplBase, global::Windows.Foundation.IReferenceArray<T>
	{
	    private T[] _value;

	    public ReferenceArrayImpl(T[] obj, global::Windows.Foundation.PropertyType type) : base(obj, type)
	    {
	        _value    = obj;
	        m_unboxed = true;
	    }

	    [global::System.Runtime.InteropServices.McgAccessor(global::System.Runtime.InteropServices.McgAccessorKind.PropertyGet, "Value")]
	    public T[] get_Value()
	    {
	        if (! m_unboxed)
	        {
	            _value = (T[]) m_data;
	            m_unboxed = true;
	        }

	        return _value;
	    }
	}

	internal class ReferenceUtility
	{
	    internal static object GetWellKnownScalar(global::Windows.Foundation.IPropertyValue ipv, global::Windows.Foundation.PropertyType type)
	    {
	        switch (type)
	        {
	            case global::Windows.Foundation.PropertyType.UInt8:
	                return ipv.GetUInt8();

	            case global::Windows.Foundation.PropertyType.Int16:
	                return ipv.GetInt16();

	            case global::Windows.Foundation.PropertyType.UInt16:
	                return ipv.GetUInt16();

	            case global::Windows.Foundation.PropertyType.Int32:
	                return ipv.GetInt32();

	            case global::Windows.Foundation.PropertyType.UInt32:
	                return ipv.GetUInt32();

	            case global::Windows.Foundation.PropertyType.Int64:
	                return ipv.GetInt64();

	            case global::Windows.Foundation.PropertyType.UInt64:
	                return ipv.GetUInt64();

	            case global::Windows.Foundation.PropertyType.Single:
	                return ipv.GetSingle();

	            case global::Windows.Foundation.PropertyType.Double:
	                return ipv.GetDouble();
	        }

	        global::McgInterop.McgCoreHelpers.Assert(false);

	        return null;
	    }

	    internal static object GetWellKnownValue(global::Windows.Foundation.IPropertyValue ipv)
	    {
	        global::Windows.Foundation.PropertyType type = ipv.get_Type();

	        switch (type)
	        {
	            case global::Windows.Foundation.PropertyType.UInt8:
	            case global::Windows.Foundation.PropertyType.Int16:
	            case global::Windows.Foundation.PropertyType.UInt16:
	            case global::Windows.Foundation.PropertyType.Int32:
	            case global::Windows.Foundation.PropertyType.UInt32:
	            case global::Windows.Foundation.PropertyType.Int64:
	            case global::Windows.Foundation.PropertyType.UInt64:
	            case global::Windows.Foundation.PropertyType.Single:
	            case global::Windows.Foundation.PropertyType.Double:
	                return GetWellKnownScalar(ipv, type);

	            case global::Windows.Foundation.PropertyType.Char16:
	                return ipv.GetChar16();

	            case global::Windows.Foundation.PropertyType.Boolean:
	                return ipv.GetBoolean();

	            case global::Windows.Foundation.PropertyType.String:
	                return ipv.GetString();

	            case global::Windows.Foundation.PropertyType.DateTime:
	                return ipv.GetDateTime();

	            case global::Windows.Foundation.PropertyType.TimeSpan:
	                return ipv.GetTimeSpan();

	            case global::Windows.Foundation.PropertyType.Guid:
	                return ipv.GetGuid();

	            case global::Windows.Foundation.PropertyType.Point:
	                return ipv.GetPoint();

	            case global::Windows.Foundation.PropertyType.Size:
	                return ipv.GetSize();

	            case global::Windows.Foundation.PropertyType.Rect:
	                return ipv.GetRect();

	            case global::Windows.Foundation.PropertyType.UInt8Array:
	                {
	                    byte[] array;
	                    ipv.GetUInt8Array(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.Int16Array:
	                {
	                    short[] array;
	                    ipv.GetInt16Array(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.UInt16Array:
	                {
	                    ushort[] array;
	                    ipv.GetUInt16Array(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.Int32Array:
	                {
	                    int[] array;
	                    ipv.GetInt32Array(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.UInt32Array:
	                {
	                    uint[] array;
	                    ipv.GetUInt32Array(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.Int64Array:
	                {
	                    long[] array;
	                    ipv.GetInt64Array(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.UInt64Array:
	                {
	                    ulong[] array;
	                    ipv.GetUInt64Array(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.SingleArray:
	                {
	                    float[] array;
	                    ipv.GetSingleArray(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.DoubleArray:
	                {
	                    double[] array;
	                    ipv.GetDoubleArray(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.Char16Array:
	                {
	                    char[] array;
	                    ipv.GetChar16Array(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.BooleanArray:
	                {
	                    bool[] array;
	                    ipv.GetBooleanArray(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.StringArray:
	                {
	                    string[] array;
	                    ipv.GetStringArray(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.InspectableArray:
	                {
	                    object[] array;
	                    ipv.GetInspectableArray(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.DateTimeArray:
	                {
	                    global::System.DateTimeOffset[] array;
	                    ipv.GetDateTimeArray(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.TimeSpanArray:
	                {
	                    global::System.TimeSpan[] array;
	                    ipv.GetTimeSpanArray(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.GuidArray:
	                {
	                    global::System.Guid[] array;
	                    ipv.GetGuidArray(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.PointArray:
	                {
	                    global::Windows.Foundation.Point[] array;
	                    ipv.GetPointArray(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.SizeArray:
	                {
	                    global::Windows.Foundation.Size[] array;
	                    ipv.GetSizeArray(out array);
	                    return array;
	                }

	            case global::Windows.Foundation.PropertyType.RectArray:
	                {
	                    global::Windows.Foundation.Rect[] array;
	                    ipv.GetRectArray(out array);
	                    return array;
	                }
	        }

	        return null;
	    }
	}
}

